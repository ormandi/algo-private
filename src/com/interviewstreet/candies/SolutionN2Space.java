package com.interviewstreet.candies;

import java.io.BufferedReader;
import java.io.InputStreamReader;

public class SolutionN2Space {
  private class Subproblem {
    public final long v;     // optimal number of candies on the interval
    public final long l;     // number of candies at the left end of the interval
    public final long r;     // number of candies at the right end of the interval
    public final int llii;   // length of left incremental interval
    public final int lrii;   // length of right incremental interval
    
    public Subproblem() {
      this(1, 1, 1, 1, 1);
    }
    
    public Subproblem(long v, long l, long r, int llii, int lrii) {
      this.v = v;
      this.l = l;
      this.r = r;
      this.llii = llii;
      this.lrii = lrii;
    }
  }
  
  public static void main(String[] args) {
    try {
      // open stdin as reader and create and instance of current class for instantiating subproblems
      BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
      SolutionN2Space s = new SolutionN2Space();
      
      // number of children
      final int N = Integer.parseInt(in.readLine());
      
      // allocate memory for ranks and computation
      int[] rank = new int[N];
      Subproblem[][] opt = new Subproblem[N][];
      for (int i = 0; i < N; i ++) {
        opt[i] = new Subproblem[i + 1];
      }
      
      // read ranks of children line-by-line
      int i = 0;
      String line = in.readLine();
      while (line != null) {
        rank[i] = Integer.parseInt(line);
        opt[i][i] = s.new Subproblem();
        
        // read the next line
        i ++;
        line = in.readLine();
      }
      
      // compute optimal solution
      for (int length = 1; length < N; length ++) {
        for (int j = length; j < N; j ++) {
          i = j - length;
          // compute opt[i,j] which is stored at position opt[j,i]
          
          // select minimum on concatenation of subproblems
          long minV = Integer.MAX_VALUE;
          Subproblem minS = null;
          
          for (int k = i; k < j; k ++) {
            final Subproblem opt1 = opt[k][i];
            final long len1 = k -i + 1;
            final Subproblem opt2 = opt[j][k+1];
            final long len2 = j - k;
            
            // new values based on base case when r[k] == r[k+1]
            long v = opt1.v + opt2.v;
            long l = opt1.l;
            long r = opt2.r;
            
            // this part of the subproblem completely depends on ONLY the ranks, i.e. it won't be modified latter
            final int llii = (opt1.llii == len1 && rank[k] < rank[k+1]) ? opt1.llii + opt2.llii : opt1.llii;
            final int lrii = (len2 == opt2.lrii && rank[k] > rank[k+1]) ? opt1.lrii + opt2.lrii : opt2.lrii;
            
            // compute difference of candies near the join 
            final long deltakp1 = opt1.r  - opt2.l + 1;
            final long deltak = opt2.l - opt1.r + 1;
            
            if (rank[k] < rank[k+1] && deltakp1 > 0) {
              v += opt2.llii * deltakp1;
              r = (opt2.llii == len2) ? opt2.r + deltakp1 : opt2.r;
            } else if (rank[k] > rank[k+1] && deltak > 0) {
              v += opt1.lrii * deltak;
              l = (opt1.lrii == len1) ? opt1.l + deltak : opt1.l;
            }
            
            // update the current minimal value of v if necessary 
            if (v < minV) {
              // current subproblem (generated by joining opt[i,k] and opt[k+1,j]) is better than the current best value
              minV = v;
              minS = s.new Subproblem(v, l, r, llii, lrii);
            }
          }
          
          // compute opt[i,j] which is stored at position opt[j,i]
          opt[j][i] = minS;
        }
      }
      
      // show solution
      final Subproblem result = opt[N-1][0];
      System.out.print(result.v);
      
      // close input
      in.close();
    } catch (Exception e) {
      throw new RuntimeException(e); // dirty exception handling
    }
  }
}